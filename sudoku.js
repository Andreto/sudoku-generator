// Sudoku Generator | Andreas TÃ¶rnkvist | 2021-02-13

var board = [];
var printBoard;
var solutionBoard = [];
var fillSpots = 30;
var boardElem = document.getElementById("sudoku-board");
var fillRange = document.getElementById("fill-range");

const urlParams = new URLSearchParams(window.location.search);

// Range-input for how much of the board should be filled
fillRange.addEventListener("input", function () {
    document.getElementById("filled-spots-value").innerHTML = fillRange.value;
    fillSpots = parseInt(fillRange.value);
});

// Checks if a id querystring is addeded to the url and if so it uses the query to fill out the board.
// The board state is saved as a string containing the value for all the 81 spots.
// The id is being generated by the getBoardId() function.
function checkQueryId() {
    if (urlParams.get("id")) {
        var id = urlParams.get("id");
        if (id.length == 81) {
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    board[i][j] = id.charAt(i*9 + j)
                }
            }
            printBoard = board;
            displayBoard();
        }
    }
}

// Creates the html elements and fills the board array with empty objects.
function initBoardFill() {
    for (let i = 0; i < 9; i++) {
        board.push([]);
        var tr = document.createElement("tr");
        for (let j = 0; j < 9; j++) {
            var td = document.createElement("td");
            tr.appendChild(td);
            board[i].push([0]);
        }
        boardElem.appendChild(tr);
    }
}

// Inserts the printBoard values into the html table.
// the printBoard array is used instead of the board array, to separate the fully filled board (essentially the answer) and the board that is meant to be played.
function displayBoard() {
    var trs = boardElem.querySelectorAll("tr");
    for (let i = 0; i < 9; i++) {
        var tds = trs[i].querySelectorAll("td");
        for (let j = 0; j < 9; j++) {
            if (board[i][j] != 0) {
                tds[j].innerHTML = board[i][j];
            } else {
                tds[j].innerHTML = " ";
            }
        }
    }
}

// Resets the board by removing the html table and the contents of the board array, and then running initial board fill again.
function resetBoard() {
    boardElem.innerHTML = "";
    board = [];
    initBoardFill();
}

// Generates a id that can be used in a query string to save or share the board.
// The incoming id is being processed in the checkQueryId() function.
function getBoardId() {
    var out = "";
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            out += board[i][j].toString();
        }
    }
    return(out);
}

// Calls getBoardId(), combines the id with a url-string and copies this string to the users clipboard.
function shareButton() {
    var copyInput = document.getElementById("copy-link-text");
    copyInput.value = "https://andreto.github.io/sudoku-generator/?id=" + getBoardId();
    copyInput.select();
    copyInput.setSelectionRange(0, 99999); // For mobile
    document.execCommand("copy");
    document.getElementById("copy-confirm").style.visibility = "inherit";
}

// Checks if a value (a) can be inserted at board position (x, y).
// If a is already present in the row, column, or box it can not be placed.
function getValidFill(x, y, a) {
    var row = new Array(9);
    var col = new Array(9);
    var box = new Array(9);

    // Determents which of the nine boxes the square is located in.
    var xSt = Math.floor(x/3)*3;
    var ySt = Math.floor(y/3)*3;

    // Row, Column
    for (let i = 0; i < 9; i++) {
        row[i] = board[y][i];
        col[i] = board[i][x];
    }

    // Box
    for (let i = xSt; i < xSt + 3; i++) {
        for (let j = ySt; j < ySt + 3; j++) {
            box[j*3 + i] = board[j][i];
        }
    }

    return(!(row.includes(a) || col.includes(a) || box.includes(a)))
}

// Generates a completely filled sudoku board.
// Starts from the top-right square and works its way down making sure it does not place a number that breaks the sudoku board.
// Even if the number being placed does not break the board up to this point it might make all numbers invalid on a later square.
// If no number can be placed on a square without breaking the rules the board is reset and the generation starts over again.
// The number of tries averages around 250
function generateBoard() {
    document.getElementById("copy-confirm").style.visibility = "hidden";
    var invalid = true;
    var loopCount = 0;
    var i;
    var valid;
    while (invalid) {
        resetBoard();
        i = 0;
        valid = true;
        while (i < 81) {
            var x = i % 9;
            var y = Math.floor(i/9);
            var a = Math.floor(Math.random() * 9);
            for (let ii = 0; ii < 9; ii++){
                let aa = ((a+ii)%9)+1;
                if (getValidFill(x, y, aa)) {
                    board[y][x] = aa;
                    ii = 9;
                }
            }
            if (board[y][x] == 0) {
                i = 82;
                valid = false;
            }
            i++
        }
        if (valid) {
            invalid = false;
        }
        loopCount++;
        if (loopCount > 1000) {
            //debugger;
        }
    }

    // Board generation complete 
    console.log("Tries made:", loopCount);
    solutionBoard = board;
    filterBoard();
}

function filterBoard() {
    // Filling the board with generated values
    var checkList = [];
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            checkList.push(i.toString() + j.toString())
        }
    }

    for (let i = 0; i < 81 - fillSpots;) {
        var n = Math.floor(Math.random() * 100000) % checkList.length;
        var x = parseInt(checkList[n].charAt(0));
        var y = parseInt(checkList[n].charAt(1));

        checkList = checkList.filter(e => e !== checkList[n]);

        var val = board[y][x];
        board[y][x] = 0;
        var dist = true;
        for (let ii = 1; ii <= 9; ii++) {
            if (ii != val) {
                if (getValidFill(x, y, ii)) {
                    dist = false;
                }
            }
        }
        //console.log("dist", dist, "x", x,  "y", y, "val", val,  "i", i);
        //console.log(checkList);
        if (val != 0 && dist) {
            board[y][x] = 0;
            i++
        } else {
            board[y][x] = val;
        }

        if (checkList.length == 0) {
            console.log("Failed Filtering")
            i = 100;
        }
    }
    printBoard = board;
}